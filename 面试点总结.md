# **C语言**

## **必问**

### **局部变量能否和全局变量重名**
能, 局部会屏蔽全局

### **数组的特点**
- 长度固定
- 存储相同类型
- 连续内存存储
- 下标访问
- 缺乏越界检查

### **内存访问越界**
- **读越界**
	- 程序从一个分配的内存区域之外的地址读取数据
- **写越界**
	- 程序向一个分配的内存区域之外的地址写入数据

### **什么是内存泄漏以及如何解决**
- 内存泄漏是指程序动态分配的堆内存因未释放或无法释放, 导致系统内存资源浪费的现象, 可能引发程序运行速度下降或系统崩溃, 长时间未释放内存最终会影响系统可靠性
- 常见情况 :
	- 忘记释放内存
		- 使用delete或free释放内存
	- 重复申请内存, 未释放内存再次申请, 会导致原内存泄露
		- 在申请新内存之前, 先释放旧内存
	- 静态变量导致内存泄漏, 静态变量在程序运行期间不会释放, 如果静态变量持有大量内存, 也会导致内存泄漏
		- 避免静态变量持有大量内存, 或者在程序退出前手动释放内存

### **函数指针与指针函数的区别**

|          | 指针函数          | 函数指针            |
| -------- | ------------- | --------------- |
| **本质**   | 函数            | 指针变量            |
| **声明重点** | `int* func()` | `int (*func)()` |
| **作用**   | 返回指针值         | 指向函数代码          |
| **使用场景** | 动态内存分配、返回数组等  | 回调函数、策略模式等      |

### **sizeof和strlen的区别**
- strlen()是一个字符串函数，只能计算字符串的长度，遇到'\0'就会结束,不会把'\0'也一并计算进去
- sizeof()是一个运算符, 能够计算出数据类型、变量、常量的大小 (计算指针时返回的是指针本身的大小)

### **const关键字的作用**


### **static关键字的作用**

### **内联函数**

### **回调函数的机制**

### **结构体和联合体的区别**

### **大端序和小端序**

|     | 小端序        | 大端序         |
| --- | ---------- | ----------- |
| **定义**  | 高位字节存储在低地址 | 低位字节存储在低地址  |
| **用途**  | 网络传输与文件存储  | 计算机内部处理数据   |
| **原因**  | 统一规定字节序    | 从低位开始计算效率更高 |

### **条件编译机制**


### **宏定义 (宏函数) 和内联函数的区别**


### **C语言内存分布**


### **栈和堆的区别**

|          | 栈                                           | 堆                                               |
| -------- | ------------------------------------------- | ----------------------------------------------- |
| **管理方式** | 系统自动分配                                      | 堆的申请和释放工作由程序员控制, 容易产生内存泄漏                       |
| **空间大小** | 默认为8MB, 远小于堆                                | 虚拟内存的大小                                         |
| **生长方向** | 向下, 内存地址由高到低                                | 向上, 内存地址由低到高                                    |
| **分配方式** | 静态分配由系统完成, 动态分配由alloca函数进行分配, 由系统进行释放       | 动态分配, 释放需要程序员自己控制                               |
| **分配效率** | 高. 栈由系统操作自动分配, 会在硬件层级对栈提供支持; 分配专门的寄存器存放栈的地址 | 低, 堆由库函数或运算符来完成申请与管理, 实现机制较为复杂, 频繁的内存申请容易产生内存碎片 |
| **存放内容** | 函数返回地址, 相关参数, 局部变量和寄存器内容等                   | 一般情况, 堆顶使用一个字节的空间来存放堆的大小, 具体内容由程序员来填充           |

## **重点**

### **变量声明和定义的区别**
- 为变量分配地址和存储空间的称为定义, 不分配地址的称为声明
- 一个变量可以在多个地方声明, 但是只在一个地方定义
- 加入extern修饰的是变量的声明, 说明此变量将在文件以外或在文件后面部分定义

### **变量的作用域**
- 变量的作用域决定了变量在程序中的可见性和生命周期
- C语言中的变量作用域主要可以分为两种 :

|          | 局部作用域               | 全局作用域               |
| -------- | ------------------- | ------------------- |
| **定义位置** | 函数内部                | 所有函数之外              |
| **可见范围** | 仅在定义它们的函数内部可见       | 整个程序可见              |
| **生命周期** | 函数执行期间存在, 函数结束后内存释放 | 程序开始执行时分配, 程序结束时释放  |
| **特点**   | 每次函数调用都会重新分配内存      | 使用extern关键字在其他文件中声明 |

| **static修饰** | 局部变量               | 全局变量          |
| ------------ | ------------------ | ------------- |
| **作用域**      | 文件作用域              | 限制为定义它的源文件内可见 |
| **生命周期**     | 静态存储期, 整个程序执行期间都存在 | 不变 (整个程序执行期间) |
| **特点**       | 保留上一次函数调用时的值       |               |

### **野指针**
#### **定义**
- 指针变量指向不可知内存区域的现象
#### **成因**
- 未初始化
- 释放之后未置空
- 操作超越变量作用域
#### **危害**
- **程序崩溃**
	- 野指针可能指向无效的内存地址, 尝试访问或修改这些地址上的内容会导致程序崩溃 (如段错误, 访问冲突等)
- **数据损坏**
	- 如果野指针指向了已经分配给其他变量的内存地址, 修改该地址上的内容可能会导致其他变量的值被意外改变, 从而导致数据损坏
- **安全漏洞**
	- 缓冲区溢出、堆溢出等, 这些漏洞可能被恶意软件利用来执行恶意代码或窃取敏感信息
- **难以调试**
	- 在程序崩溃时, 很难确定崩溃的原因是否与野指针有关
#### **避免**
- 初始化指针
- 检查指针
- 释放内存后重置指针
- 避免越界
- 使用安全的编程实践

### **数组指针与指针数组的区别**

|        | 指针数组           | 数组指针               |
| ------ | -------------- | ------------------ |
| **本质** | 数组，元素是指针       | 指针，指向整个数组          |
| **声明** | `int *arr[10]` | `int (*arr)[10]`   |
| **大小** | 元素个数 × 指针大小    | 固定为指针大小(通常8字节)     |
| **用途** | 字符串数组、多级指针     | 处理多维数组、数组参数传递      |
| **访问** | `arr[i]` 是指针   | `(*arr)[i]` 访问数组元素 |

### **strcpy和memcpy的区别**

|        | strcpy            | memcpy |
| ------ | ----------------- | ------ |
| **内容** | 字符串               | 任意内容   |
| **方法** | 不需要指定长度, 遇到"\0"结束 | 限定复制长度 |
| **用途** | 复制字符串             | 复制其他类型 |

### **地址传参和值传参**

- **地址传参**
	- 指函数调用时实参的地址或指针作为形参传递给函数, 函数内对形参所指向的内存空间进行操作会改变实参的值
- **值传参**
	- 指将函数调用时实参的值复制一份给形参, 函数内对形参进行操作不会影响实参的值

### **什么是地址对齐**
- 地址对齐与系统字长有关. 字长的概念指的是处理器在一条指令中的数据处理能力
- CPU字长确定之后, 相当于明确了系统每次存取内存数据时的边界
- 总结 : 如果一个数据满足以最小单元数存放在内存中, 则称它地址是对齐的, 否则是未对齐的. 如果发生数据地址未对齐的情况, 有些系统会直接罢工, 有些系统则降低性能

### **枚举的作用和用处**


### **